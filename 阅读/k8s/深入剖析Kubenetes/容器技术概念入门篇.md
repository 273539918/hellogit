# 容器技术概念入门篇

## 05 白话容器基础（一）：从进程说开去



### 05.1 容器只是一种特殊的进程

容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”。对于Docker等大多数Linux容器来说，Cgroups技术是用来制造约束的主要手段，而Namesapce技术则是用来修改进程视图的主要方法。

创建一个容器

```shell
docker run -it busybox /bin/sh 
```

it参数告诉了Docker项目在启动容器后，需要给我们分配一个文本输入输出环境，也就是TTY，跟容器的标准输入相关联，这样我们就可以和这个Docker容器进行交互了。而/bin/sh 就是我们要在Docker容器里运行的程序。在该容器里，/bin/sh的PID是1，而实际在宿主机上它的PID是1000。这种机制，其实就是对被隔离应用的进程空间做了手脚，使得这些进程只能看到重新计算过的进程编号。这种技术，就是Linux里面的Namespace机制。

所以。Docker容器这个听起来玄而又玄的概念，实际上是在创建容器进程时，指定了这个容器所需要启动的一组Namespace参数。这样，容器就只能“看”到当前Namespace所限定的资源、文件、设备、状态或者配置。而对于宿主机以外其他不相关的程序，就完全看不到了

### 05.2 Namespace实现的基本原理

Namespace的使用方式也非常有意思：它其实只是Linux创建新进程的一个可选参数。Linux创建进程的方式如下：

```
int pid = clone(main_function,stack_size,SIGCHLD,NULL)
```

这个系统调用就会为我们创建一个新的进程，并且返回它的进程号Pid。而当我们用clone()系统调用时，指定CLONE_NEWPID参数时：

```
int pid = clone(main_function,stack_size,CLONE_NEWPID | SIGCHLD,NULL)
```

这时，新创建的进程将会“看到”一个全新的进程空间，在这个进程空间里，它的PID是1。之所以说“看到”，是因为这只是一个“障眼法”，它在宿主机真实的进程空间里，这个进程的PID还是真实的数值，比如100。

除了我们刚刚用到的PID Namespace，Linux操作系统还提供了Mount、UTS、IPC、Network和User这些Namespace，用来对各种不同的进程上下文进行“障眼法”操作。比如，Mount Namespace，用于让被隔离进程只看到当前Namespace里的挂载点信息；Network Namespace用于让被隔离进程看到当前Namespace里的网络设备和配置。 这，就是Linux容器最基本的实现原理了。

### 05.3 容器与虚拟机的区别

虚拟机的工作原理是通过硬件虚拟化功能，模拟出运行一个操作系统需要的各种硬件，比如CPU、内存、i/o设备等等。然后，它在这些虚拟的硬件上安装了一个新的操作系统，这样，用户的应用进程就可以运行在这个虚拟的机器中，它能看到的自然只有这个虚拟操作系统的文件和目录，以及这个机器里的虚拟设备。这就是为什么虚拟机也能起到将不同的应用进程相互隔离的作用。

容器与真实存在的虚拟机不同，在使用Docker的时候，并没有一个真正的“Docker容器”运行在宿主机里。Docker项目帮助用户启动的，还是原来的那些进程，只不过在创建这些进程时加上了各种各样的Namespace参数。