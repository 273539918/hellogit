## 序1

- 十年前，当我们坐在课堂里学习算法的时候，我们学到的是如何用人脑寻求解法，然后把解法写成程序，让计算机照着执行去解决问题。这是”经典算法“。
最近十几年，随着Internet产业的兴起，Internet服务在不断取代原来由人提供的服务，这就要求机器拥有一定程序上能取代人的“智能”。在搜索引擎、
推荐系统和广告系统等各个领域，类似上述“识别数字”的问题越来越多，而人工智能和机器学习的应用也越来越深入我们的生活。机器学习算法的设计目标
和“经典算法”不同—————不是让人来想解法，而是让计算机从数据归纳知识————有了这些知识，计算机就能自己寻求解法。

### 2.1 程序的基本结构

- 递归结构使用的函数递归调用，会增加任务的栈空间使用，用递归方法解决问题的规模受系统栈空间的约束

### 2.3 数据结构和数学模型与算法的关系

- 有时候，工具可以决定思维。为什么要强调数据结构的重要性：因为数据结构是建立解决问题的数学模型的基础，如果不了解数据结构，就没有办法建立模型，或者建立
的模型不合适，倒是算法演化困难，甚至无法实现。


### 3.1 贪婪法

- 贪婪法和动态规划法以及分治法一样，都需要对问题进行分解，定义最优解的子结构。但是，贪婪法与其他方法最大的不同在于，贪婪法每一步选择之后，
局部最优解就确定了，不再进行回溯处理，也就是说，每一个步骤的局部最优解确定以后，就不再修改，直到算法结束。因为不进行回溯处理，贪婪法只在很少
的情况下得倒真正的最优解，比如最短路径问题、图的最小生成树问题。大多数情况下，由于选择策略的“短视”，贪婪法会错过真正的最优解，得不到问题的真
正答案。但是贪婪法简单高效、省去了为找最优解可能需要的穷举操作，可以得到与最优解比较接近的近似最优解。


### 3.2 分治法

- 分治法也是一种解决问题的常用模式，分治法的设计思想是将无法着手解决的大问题分解成一系列规模较小的相同问题，然后逐个解决小问题，即所谓的分
而治之。分治法产生的子问题与原始问题相同，只是规模减小，反复使用分治方法，可以使得子问题的规模不断减小，直到能够被直接求解为止。


## 9. 项目管理与图的拓扑排序

### 9.3 关键路径算法

- 工程中的一个活动何时开始依赖于其前驱活动何时结束，只有所有的前驱活动都结束后这个活动才可以开始。前驱活动都结束的时间就是这个活动的最早开始
时间。
- 在时间余量允许的范围之内推迟一段时间开始活动也不会影响工程的最终完成时间，活动的最早开始时间加上这个时间余量就是活动的最晚开始时间。活动
不能在最早开始时间之前开始，当然，也不能在最晚开始时间之后开始
- 如果一个活动的时间余量为0，即该活动的最早开始时间和最晚开始时间相等，则这个活动就是关键活动，由这些关键活动串起来的一个工程活动路径就是
关键路径。

## 10. RLE压缩算法与PCX图像文件格式

### 10.1 RLE压缩算法

- RLE压缩算法的基本思路就是把数据按照线性序列分成两种情况：一种是连续的重复数据块，另一种是连续的不重复数据块。RLE算法的原理就是用一个表示
数据块的属性加一个数据块代表原来连续的若干数据块，从而达到节省存储空间的目的。


## 11. 算法与历法

### 11.3 农历朔日（新月）的天文学计算

- 日月合朔的时候，太阳、月亮和地球三者接近一条直线，月亮未被照亮的那一面对着地区，因此地球上看不到月亮，此时又被称为新月

### 11.4 农历的生成算法

- 在中国古代历法中，十二生肖的计算与天干地支有很大关系，所以在“论天干地支、计算廿四节气”的情况下，“立春”节气应该是新生肖的开始。对于普通老
百姓来说，习惯于认为正月初一是生肖年的开始，因此，正月初一和“立春”节气之间出生的小孩，在确定属相的时候就有点麻烦。属马还是属羊？这是个问题

## 12. 实验数据与曲线拟合

- 曲线拟合不仅仅是根据离散数据画出一条曲线，曲线拟合更重要的意义是通过特定的曲线拟合算法，推算出一个（或一系列）能逼近离散数据并能维持统计
误差最小的数学解析表达式，也就是曲线拟合曲线的数学方程。

## 16. 全局最优解与遗传算法

- 遗传算法将问题的解定义为进化对象的个体，对若干个体组成的种群进行选择、交叉（杂交）和变异处理，没处理一次种群就“进化”一代。只要评估和选
择策略合适，经过若干次“进化”之后，种群中就会出现比较接近最优解的个体，对应的就是问题的近式最优解。这就是遗传算法的原理
- 轮盘赌选择方法：每个个体被选择的概率就像轮盘上的一个扇区，面积大的扇区被选中的概率就比较大，面积小的扇区被选中的概率就比较小


## 17. 计算器程序与大整数计算
- 平方-乘降幂法 ，也称为二进制平方和乘法 。 例：计算a的九次方，根据乘方的定义：a的九次方 = a * a的八次方，只要能计算出a的8次方，则计算a
的九次方只要做一次乘法。a的八次方又可以分解为：a的四次方*a的四次方，因此，只需要计算出a的四次方，a的8次方也只需要一次乘法就可以得到。
继续这个过程，a的四次方又可以分解为:a的二次方*a的二次方，只需要计算出a的二次方，则只需一次乘法就可以得到a的四次方。最后计算a的二次方也
只需要一次乘法。最终, a的九次方变成了4次乘法就可以计算得到，提高了计算效率。

## 18. RSA算法

- 根据数学家的证明，只要用2和3作为随机数进行两次检验，就可以100%正确地检验小于1373653的所有素数。再比如，只要用2、3、4、7、11作为随机数
进行5次校验，就可以100%正确地检验小于215230289747的所有素数。这些经过证明的经验值都是100%正确的，但是不在上述范围中的其他大
素数的判断，目前还只能是概率结果，也就是说，即使能通过检验，也要打上“伪素数”的标签

- 数字签名的一般过程是：用户A用选择的哈希算法计算出文件M的HASH值，然后用自己的私钥对这个HASH值进行加密，这个过程就是“签名”。
现在A把文件M(不加密)和加密后的HASH值发给B,B于是用A的公钥对HASH值解密，然后再计算文件M的HASH值，比较文件的HASH值是否和A发送过来的HASH值
一样，如果一样则说明文件确实A发来的，并且文件没有被修改。否则说明文件不是A发出的，或者文件在传递过程中被篡改了。由此可知，数字签名除了证明
文件M是A发出的，还可以验证文件M是否被其他人（包括接收者）篡改或改造。


## 附录

- 用一重循环遍历二维表关键是对下标的处理，对于一个M*N的二维表，可以用以下方法解出对应的二维下标：int row = i / M ; int col = i % N ，
反过来也可以用以下公式将二维坐标还原为一维坐标： int row * N + col







