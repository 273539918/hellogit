# The Google File System





## 0、概要

### 总结

google设计并实现的GFS分布式文件系统，能够运行在大量廉价硬件上，提供容错能力并具有较好的性能，在google已经大范围使用。这篇文章会对GFS进行介绍

### 内容

我们已经设计并实现了Google File System，这是一个可扩展的分布式文件系统，用于大型分布式数据密集型应用程序。它可以在廉价的普通硬件上运行并提供容错能力，并且可以为大量客户端提供较高的聚合性能。

在实现与以前的分布式文件系统相同的许多目标的同时，我们的设计是由对当前和预期的应用程序工作负载和技术环境的观察推动的，这反映出与某些早期文件系统假设的明显偏离。这导致我们重新审视传统选择，并探索根本不同的设计要点。

这个文件系统已成功满足我们的存储需求。 它广泛地在Google内部部署，作为存储平台，用于生成和处理我们的服务使用的数据以及需要大量数据集的研发工作。迄今为止，最大的群集在一千多台计算机上的数千个磁盘上提供了数百TB的存储，数百个客户端同时访问该群集。

在本文中，我们介绍了旨在支持分布式应用程序的文件系统接口扩展，讨论了我们设计的许多方面，并报告了来自微基准测试和实际使用情况的测量结果。



## 1. 介绍



### 总结

Google文件系统（GFS）的设计需要考虑：

 1）组件容错和自动恢复  
 2）文件庞大，需要重新考虑I/O操作和块大小 
 3）访问模式相对固定，"append"是性能优化和原子性保证的重点 

### 内容

我们已经设计并实现了Google文件系统（GFS），以满足Google数据处理快速增长的需求。 GFS与以前的分布式文件系统具有许多相同的目标，例如性能，可伸缩性，可靠性和可用性。 但是，其设计是由对我们当前和预期的应用程序工作负载和技术环境的主要观察驱动的，这反映出与某些早期文件系统设计假设存在明显差异。 我们重新审视了传统选择，并探索了设计中的根本不同点。

首先，组件故障是正常现象，而不是异常情况。 该文件系统由数百个甚至数千个由廉价PC存储机器组成，并且可被相当数量的客户端访问。组件的数量和质量实际上保证了某些组件在任意时刻的不可用以及某些组件无法从当前的故障中恢复，我们已经看到了由应用程序错误，操作系统错误，人为错误以及磁盘，内存，连接器，网络和电源故障引起的问题。 因此，持续监视，错误检测，容错和自动恢复必须是系统不可或缺的。

其次，按照传统标准，文件非常庞大。 GB大小文件是常见的。 每个文件通常包含许多应用程序对象，例如Web文档。我们无法定期处理TB级增长的数十亿个对象，即使文件系统可以支持它，也无法管理数十亿个KB大小的文件。因此，必须重新考虑设计参数，例如I / O操作和块大小。

第三，大多数文件是通过“附加”新数据而不是覆盖现有数据来进行改变的。文件内的随机写入实际上是不存在的。 写入后，仅读取文件，并且通常只能顺序读取。各种数据共享这些特征。 有些可能会构成大型存储库，数据分析程序会扫描这些存储库。 有些可能是通过运行应用程序连续生成的数据流。 有些可能是档案数据。 某些结果可能在一台机器上产生中间结果，而在另一台机器上同时产生或稍后产生。鉴于对大型文件的这种访问模式，“附加”成为性能优化和原子性保证的重点，而在客户端中缓存数据块却失去了吸引力。

第四，共同设计应用程序和文件系统API，提高灵活性，可以使整个系统受益。例如，我们放松了GFS的一致性模型，以极大地简化文件系统，而不会给应用程序带来繁重的负担。我们还引入了原子附加操作，以便多个客户端可以并发附加到文件，而无需在它们之间进行额外的同步。这些将在本文后面详细讨论。

当前部署了多个GFS群集以用于不同的目的。 最大的服务器拥有1000多个存储节点，超过300 TB的磁盘存储，并且连续不断地被不同计算机上的数百个客户端大量访问。



## 2、 设计概述

### 总结

 设计的系统有如下假设：
（1）系统由大量廉价PC组成，软件侧实现容错和故障恢复
（2）大部分文件为小文件（100MB左右），大文件较少
（3）读操作主要是大量的流(顺序)读取 和少量的随机读取
（4）写操作主要是大量的append(追加)写入，一旦写入，很少修改
（5）支持高并发的写入语义
（6）设计上高吞吐比低延迟更重要

### 内容

#### 2.1 假设条件

在设计满足我们需求的文件系统时，我们以既带来挑战又带来机遇的假设为指导。 我们之前提到了一些关键的观察，现在更详细地阐述了我们的假设。
（1）该系统由许多经常发生故障的廉价PC组成。 它必须不断地自我监控，并定期检测，容忍和及时从组件故障中恢复。
（2）系统存储少量的大文件。 我们期望有几百万个文件，每个文件的大小通常为100 MB或更大。 多GB文件是常见的情况，应进行有效管理。 必须支持小文件，但我们不需要对其进行优化。
（3）工作负载主要包括两种读取：大型流读取和小型随机读取。 在大型流读取中，单个操作通常读取数百KB，更常见的是1 MB或更多。 来自同一客户端的连续操作通常会读取文件的连续区域。 少量随机读取通常会以任意偏移量读取几个KB。 注重性能的应用程序经常对小读取进行批处理和排序，以稳定地通过文件而不是来回移动。
（4）工作负载还具有许多大的顺序写入，这些写入将数据追加到文件中。 典型的操作大小类似于读取的大小。 一旦写入，很少再修改文件。 支持对文件中任意位置的小写操作，但不一定要有效。
（5）系统必须为同时附加到同一文件的多个客户端有效地实现定义良好的语义。 我们的文件通常被用作生产者－消费者队列或用于多种合并。 每台计算机上运行一个的数百个生产者将同时添加到文件中。 具有最小同步开销的原子性是必不可少的。 该文件可能会在以后读取，或者消费者可能正在同时读取文件。
（6）高持续带宽比低延迟更重要。 我们的大多数目标应用程序都非常重视以高速率处理大量数据，而很少有对单个读取或写入有严格响应时间要求的应用程序。



#### 2.2 接口





































