### 如何理解容器化 



如果把进程比喻做货物，把计算机比喻成货船。那么在没有集装箱之前，所有的货物都散乱地堆积在船上，相互之间和碰撞、挤压、变形。有了集装箱之后，就可以把将获取之间独立起来，相互隔离，互不影响，也更方便地搬迁、管理、运输

>就像航运业使用物理容器隔离不同的货物以在船，火车，卡车和飞机中运输一样，软件开发技术越来越多地使用容器化来隔离运行环境、依赖包、配置文件等等独立进程运行所依赖的条件。
>
>容器化提供了隔离，可移植性，敏捷性，可伸缩性以及对应用程序整个生命周期工作流进行控制的优势。 从主机操作系统中抽象出来的容器是独立的，并且变得更加可移植，可在任何平台或云上统一，一致地在任何基础架构上运行。
>
>





## kuberentes的调度器是如何工作的？

kuberentes的调度器会关注两方面的信息： 1、有哪些Pod需要调度 2、当前集群node的情况

调度器的调度分成两部分， predicates 和priorities，其中predicates决定是否能调度（硬限制），priorites决定是否能调度得更合理（软限制）。



## RBAC

Role定义了对哪些资源可以进行哪些操作

Rolebinding定义了哪些用户(组)拥有哪些role

ClusterRolebinding与Rolebinding类似，但没有namespace的限制，作用整个集群



## Service Mesh



1、 如何出现的

在原始时代，服务A和服务B通信，首先要解决的就是复杂的网络传输问题。在TCP协议出现之前，服务需要自己处理网络通信所面临的丢包、乱序、重试等一系列流控问题，因此服务实现中，除了业务逻辑外，还夹杂着对网络传输问题的处理逻辑。TCP出现后，解决了网络传输的流控问题，服务专注于处理业务逻辑。

随时分布式系统的出现，新的需求出现了：有一些所有分布式系统都需要的“通用功能”，比如负载均衡、服务发现、认证授权等。这部分“通用功能”是所有分布式服务系统所通用的，因此出现了一些面向微服务架构的开发框架，实现了分布式系统通信需要的各种通用语义功能。这些面向为服务架构的开发框架在一定程度上屏蔽了通信细节，使得开发人员使用较少的框架代码就能开发出健壮的分布式系统。

这些面向微服务架构的开发框架一般以lib库的形式存在（以Spring Cloud为代表），因此本质上会导致一些新的问题，比如：1）框架本身复杂，需要较多精力去掌握 2）这种微服务架构一般与特定语言绑定。3）与分布式服务系统耦合，无法独立透明升级。 因此，第一代Service Mesh应运而生，它将分布式服务的通信抽象为单独一层，在这一层中实现负载均衡、服务发现、认证授权等分布式系统所需要的功能，作为一个和服务对等的代理服务，和服务部署在一起，接管服务的流量，通过代理之间的通信间接完成服务之间的通信请求，这样上边所说的三个问题也迎刃而解。

需求随后出现，第一代Service Mesh由一系列独立运行的单机代理服务构成，需要统一的上层运维入口。因此出现了第二代以Istio为代表的Service Mesh



2、定义

Service Mesh：是微服务时代的TCP协议

定义：Service Mesh是一个***基础设施层\***，用于处理服务间通信。云原生应用有着复杂的服务拓扑，Service Mesh保证***请求在这些拓扑中可靠地穿梭\***。在实际应用当中，Service Mesh通常是由一系列轻量级的***网络代理\***组成的，它们与应用程序部署在一起，但***对应用程序透明\***。 

这个定义中，有四个关键词：

***基础设施层\***+***请求在这些拓扑中可靠穿梭\***：这两个词加起来描述了Service Mesh的定位和功能，是不是似曾相识？没错，你一定想到了TCP；

***网络代理\***：这描述了Service Mesh的实现形态；

***对应用透明\***：这描述了Service Mesh的关键特点，正是由于这个特点，Service Mesh能够解决以Spring Cloud为代表的第二代微服务框架所面临的三个本质问题；

3、 Service特性

总结一下，Service Mesh具有如下优点：

（1）屏蔽分布式系统通信的复杂性（负载均衡，服务发现等等），服务只用关注业务逻辑

（2）与具体语言无关

（3）对应用透明，Service Mesh组件可以单独升级

当然，Service Mesh目前也面临一些挑战：

（1）Service Mesh组件以代理模式会有一部分资源开销

（2） Service Mesh组件本身的运维管理需要一定的投入



参考： https://zhuanlan.zhihu.com/p/61901608



## Pod的状态

Pending:  kubernetes已经接受了请求，还在等待调度

Creating:  已经调度完成，需要创建容器，比如下载容器镜像

Running:  Pod已经成功运行

CrashLookBackoff： Pod失败重建次数过多，kubelet可能会延后一段时间再尝试重启它























