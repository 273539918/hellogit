## 五、调优案例分析与实战

## 5.2 案例

### 5.2.1 高性能硬件上的程序部署策略

问题：16G内存的机器上，JVM的内存设置12G，发生服务频繁长时间不响应

原因：

1、 虚拟机默认使用过了吞吐量优先收集器，回收12GB的堆，一次full GC的停顿时间高达14秒，导致服务器不响应。

2、业务场景下，程序经常需要从磁盘提取文件到内存中，导致内存中出现很多由文档序列化产生的大对象，这些大对象很多都是直接进入老年代，没有在Minor GC中清理掉。这种情况下，即使内存有12GB，也很快被耗尽

建议：

1、对于用户交互性强、对停顿时间敏感的系统，可以给Java虚拟机分配超大堆的前提是有把握把对应用程序的Full GC频率控制得足够低，至少要低到不会影响用户使用。

2、控制Full GC频率的关键是要看应用中绝大多数对象能否符合“朝生夕灭”的原则，即大多数对象的生存时间不应该太长，尤其是不能有成批量的、长生存时间的大对象产生，这样才能保障老年代空间的稳定。

3、尝试根据业务场景选择合适的垃圾收集器，比如CMS

### 5.2.2 集群间同步导致的内存溢出



问题：启用全局缓存之后，服务器多次出现内存溢出问题

原因：全局缓存在多个机器之间有网络交互，当网络情况不能满足传输要求时，重发数据在内存中不断累计，最终导致内存溢出

建议：全局缓存，可以有频繁的读操作，但不建议有频繁的写操作

### 5.2.3 堆外内存导致的溢出错误



问题： 服务器端不定时抛出内存溢出异常。加入-xx:+HeapDumpOnOutOfMemoryError，抛出内存溢出时什么文件也没产生。通过jstat发现GC并不频繁，且Eden区、Survivor区、老年代以及永久代全部都表示“情绪稳定，压力不大”，但就是照样不停抛出内存溢出异常。

原因：是堆外内存抛出的内存溢出错误，垃圾收集进行时，虚拟机虽然会对Direct Memory进行回收，但是Direct Memory 却不能像新生代、老年代那样，发现空间不足了就通知收集器进行垃圾回收，它只能等待老年代满了后Full GC，然后“顺便地”帮它清理掉内存的废弃对象。否则它只能一直等到抛出内存溢出异常时，先catch掉，再在catch里面“大喊”一声： “System.gc()!”。要是虚拟机还是不听（譬如打开了 -XX:+DisableExplicitGC开关），那就只能眼睁睁地看着堆中还有许多空闲内存，自己却不得不抛出内存溢出异常了。

建议：

除了java堆和永久代之外，注意下面这些区域还会占用较多的内存，常用的内存溢出类型：

1、 Direct Memory ： 可通过 -XX : MaxDirectMemorySize调整大小，内存不足时抛出OutOfMemoryError或者OutOfMemoryError：Direct buffer memory 

2、线程堆栈：可通过 -Xss调整大小，内存不足时抛出StackOverflowError或者OutOfMemoryError: unable to create new native thread 

3、Socket缓存区：每个Socket连接都Receive和Send两个缓存区，分别占大约37KB和25KB内存，连接多的话这块内存占用也比较可观。如果无法分配，则可能会抛出IOException：Too many open files 异常。

### 5.2.4 外部命令导致系统变慢

问题：系统在做大并发压力测试的时候，发现请求响应比较慢，发现CPU利用率很高，且大部分都是cpu_sys而不是cpu_user。排查发现，最消耗CPU资源的是"fork"系统调用。众所周知，"fork"系统调用的是Linux用来产生新进程的，在Java虚拟机中，用户编写的代码最多的只有线程的概念，不应该有进程产生

原因：原因是这个请求对于每个请求都需要执行一个外部shell脚本来获得系统的一些信息。执行这个shell脚本是通过Java的Runtime.getRuntime().exec()方法来调用。这种调用方式是可以达到目的，但是它在Java虚拟机中是非常消耗资源的操作，即使外部命令本身能很快执行完毕，频繁调用时创建进程的开销也非常可观。Java虚拟机执行这个命令的过程是：首先克隆一个和当前虚拟机拥有一样环境变量的进程，再用这个新的进程区执行外部命令，最后再退出这个进程。如果频繁执行这个操作，系统的消耗会很大，不仅是CPU，内存负担也很重。

建议：去掉这个shell脚本执行的语句，改用使用Java的API去获取这些信息

### 5.2.5 服务器JVM进程崩溃

问题： 服务器运行期间出现集群节点的虚拟机进程自动关闭的现象，且每个节点的虚拟机进程在崩溃前不久，都发生过大量相同的异常

```
java.net.SocketException: Connection rest
```

原因：服务器运行期间需要与另一个系统有网络交互，但网络调用长达3分钟才能返回，并且返回的结果都是连接中断。导致在等待的线程和Socket连接越来越多，最终在超过虚拟机的承受能力后使得虚拟机进程崩溃

解决方式： 可以修改与外部系统交互的模型，比如将异步调用修改为消息队列

### 5.2.6 不恰当数据结构导致内存占用过大

问题：有一个后台RPC服务器，使用ParNew+CMS的收集器组合。平时对外服务的Mintor GC时间约在30毫秒以内，完全可以接受。但业务上需要每10分钟加载一个约 80MB的数据文件到内存进行数据分析，这些数据会在内存中形成超过100万个HashMap<Long, Long> Entry，在这段时间里面Minor GC 就会造成超过500毫秒的停顿，对于这个停顿时间就接受不了了

原因：观察这个案例，发现平时的Minor GC时间很短，原因是新生代的绝大部份对象都是可清除的，在Minor GC之后Eden和Survivor基本上处于完全空闲的状态。而在分析数据文件期间，800MB的Eden空间很快别填满从而引发GC，但Mintor GC之后，新生代中绝大部份对象依然是存活的。我们知道ParNew收集器使用的是复制算法，这个算法的高效是建立在大部分对象都“朝生夕灭”的特性上的，如果存活对象过多，把这些对象复制到Survivor并维持这些对象引用的正确就成为一个沉重的负担，因此导致GC暂停时间明显变长。

解决方式：

（1）短期：修改虚拟机参数，让新生代中存活的对象在第一次Mintor GC后立即进入老年代，等到Major GC的时候再清理
（2）长期：修改程序，HashMap<Long,Long>结构来存储文件空间效率太低。（实际生效的值为两个Long = 8B * 2 =16B，而一个Hash<Long，Long> 需要的空间是 88B ，效率为 16/88=18%）

## 5.3 实战：Eclipse运行速度调优

通常的JVM调优思路：  升级JDK ->  编译时间和类加载时间的优化（比如禁止掉字节码验证） -> 调整内存设置控制垃圾收集频率 -> 选择收集器降低延迟