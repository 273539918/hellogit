## 五、调优案例分析与实战

## 5.2 案例

### 5.2.1 高性能硬件上的程序部署策略

问题：16G内存的机器上，JVM的内存设置12G，发生服务频繁长时间不响应

原因：

1、 虚拟机默认使用过了吞吐量优先收集器，回收12GB的堆，一次full GC的停顿时间高达14秒，导致服务器不响应。

2、业务场景下，程序经常需要从磁盘提取文件到内存中，导致内存中出现很多由文档序列化产生的大对象，这些大对象很多都是直接进入老年代，没有在Minor GC中清理掉。这种情况下，即使内存有12GB，也很快被耗尽

建议：

1、对于用户交互行强、对停顿时间敏感的系统，可以给Java虚拟机分配超大堆的前提是有把握把对应用程序的Full GC频率控制得足够低，至少要低到不会影响用户使用。

2、控制Full GC频率的关键是要看应用中绝大多数对象能否符合“朝生夕灭”的原则，即大多数对象的生存时间不应该太长，尤其是不能有成批量的、长生存时间的大对象产生，这样才能保障老年代空间的稳定。

3、尝试根据业务场景选择合适的垃圾收集器，比如CMS

## 5.2.2 集群间同步导致的内存溢出

问题：启用全局缓存之后，服务器多次出现内存溢出问题

原因：全局缓存在多个机器之间有网络交互，当网络情况不能满足传输要求时，重发数据在内存中不断累计，最终导致内存溢出

建议：全局缓存，可以有频繁的读操作，但不建议有频繁的写操作

## 5.2.3 堆外内存导致的溢出错误

问题： 服务器端不定时跑出内存溢出异常。加入-xx:+HeapDumpOnOutOfMemoryError，抛出内存溢出时什么文件也没产生。通过jstat发现GC并不频繁，且Eden区、Survivor区、老年代以及永久代全部都表示“情绪稳定，压力不大”，但就是照样不停抛出内存溢出异常。

原因：是堆外内存抛出的内存溢出错误，垃圾收集进行时，虚拟机虽然会对Direct Memory进行回收，但是Direct Memory 却不能像新生代、老年代那样，发现空间不足了就通知收集器进行垃圾回收，它只能等待老年代满了后Full GC，然后“顺便地”帮它清理掉内存的废弃对象。否则它只能一直等到抛出内存溢出异常时，先catch掉，再在catch里面“大喊”一声： “System.gc()!”。要是虚拟机还是不听（譬如打开了 -XX:+DisableExplicitGC开关），那就只能眼睁睁地看着堆中还有许多空闲内存，自己却不得不抛出内存溢出异常了。

建议：

除了java堆和永久代之外，注意下面这些区域还会占用较多的内存，常用的内存溢出类型：

1、 Direct Memory ： 可通过 -XX : MaxDirectMemorySize调整大小，内存不足时抛出OutOfMemoryError或者OutOfMemoryError：Direct buffer memory 

2、线程堆栈：可通过 -Xss调整大小，内存不足时抛出StackOverflowError或者OutOfMemoryError: unable to create new native thread 

3、Socket缓存区：每个Socket连接都Receive和Send两个缓存区，分别占大约37KB和25KB内存，连接多的话这块内存占用也比较可观。如果无法分配，则可能会抛出IOException：Too many open files 异常。

## 5.2.4 外部命令导致系统变慢

问题：系统在做大并发压力测试的时候，发现请求响应比较慢，发现CPU利用率很高，且大部分都是cpu_sys而不是cpu_user。排查发现，最消耗CPU资源的是"fork"系统调用。众所周知，"fork"系统调用的是Linux用来产生新进程的，在Java虚拟机中，用户编写的代码最多的只有线程的概念，不应该有进程产生

原因：原因是这个请求对于每个请求都需要执行一个外部shell脚本来获得系统的一些信息。执行这个shell脚本是通过Java的Runtime.getRuntime().exec()方法来调用。这种调用方式是可以达到目的，但是它在Java虚拟机中是非常消耗资源的操作，即使外部命令本身能很快执行完毕，频繁调用时创建进程的开销也非常可观。Java虚拟机执行这个命令的过程是：首先克隆一个和当前虚拟机拥有一样环境变量的进程，再用这个新的进程区执行外部命令，最后再推出这个进程。如果频繁执行这个操作，系统的消耗会很大，不仅是CPU，内存负担也很重。

建议：去掉这个shell脚本执行的语句，改用使用Java的API去获取这些信息



