## 系统诊断常见思路

## 系统饱和率 或者 错误
### 查看系统平均负载
$uptime

### 查看最新的系统日志，特别注意是否有oom-kiler以及TCP丢包
$dmesg | tail

### 查看cpu和虚拟内存的情况 , 参数1表示每隔1秒钟显示一次
$vmstat 1
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
478  0      0 196951424 3492172 119698288    0    0     0  1460 137020 384916 20 71  9  0  0
277  1      0 196918032 3492172 119699704    0    0     0  2752 110765 320958 16 54 30  0  0
570  0      0 196936496 3492172 119720336    0    0     0   304 147010 393603 23 67 10  0  0
419  0      0 196815632 3492172 119722816    0    0     0 25572 141721 388347 20 69 11  0  0
462  0      0 196837376 3492172 119724128    0    0     0  2416 135149 393098 20 69 11  0  0
465  0      0 196836864 3492172 119727616    0    0     0    12 132092 382615 20 70 10  0  0
197  0      0 196835232 3492172 119728936    0    0     0 11548 111827 309134 15 51 35  0  0
## r: 处在runnable状态的任务、包括正在运行的任务和等待运行的任务。这个值比平均负载能更好地看出CPU是否饱和。这个值不包含等待io相关## 的任务。当r的值比当前CPU个数要大的时候，系统就处于饱和状态了
## free: 以KB计算的空闲内存大小
## si,so:换入换出的内存页，如果这两只非0，表示内存不够了
## us，sy,id,wa,st：CPU时间的各项指标（对所有CPU取均值），分别表示： 用户态时间、内核态时间、空闲时间，等待io，偷取时间（虚拟化环境下系统在其他租户上的开销）
## 把用户台CPU时间(us)和内核态CPU时间(sy)加起来，我们可以进一步确认CPU是否繁忙。等待IO时间(wa)高的话，表示磁盘是瓶颈；注意，这个## 也被包含在空间时间里面(id)，CPU这个时间也是空闲的，任务因此阻塞在磁盘IO上了。你可以把等待IO的时间(wa)看做另一种形式的CPU空闲，## 它可以告诉你CPU为什么是空闲的。系统处理IO的时候，肯定是会消耗内核态时间(sy)的。如何内核态时间较多的话，比如超过20%，我们需要进一## 步分析，也许内核对IO的处理效率不高

## 把每个CPU的时间都打印出来， 可以看看CPU对任务的处理是否均匀。比如，如果某一单个CPU使用率很高的话，说明这是一个单线程应用
$mpstat -P ALL
Linux ..... 	11/22/2020 	_x86_64_	(104 CPU)
10:21:03 AM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
10:21:03 AM  all   18.03    0.01    5.04    0.62    0.00    4.81    0.00    0.00    0.00   71.49
10:21:03 AM    0   21.74    0.01    5.90    0.53    0.00    7.35    0.00    0.00    0.00   64.46
10:21:03 AM    1   18.69    0.01    5.07    0.54    0.00    4.55    0.00    0.00    0.00   71.13
10:21:03 AM    2   18.75    0.01    4.98    0.55    0.00    4.27    0.00    0.00    0.00   71.43
10:21:03 AM    3   18.81    0.01    5.04    0.55    0.00    4.23    0.00    0.00    0.00   71.35
10:21:03 AM    4   18.58    0.01    5.10    0.56    0.00    4.22    0.00    0.00    0.00   71.53
10:21:03 AM    5   18.94    0.01    5.05    0.56    0.00    4.20    0.00    0.00    0.00   71.26
10:21:03 AM    6   18.85    0.01    5.06    0.55    0.00    4.32    0.00    0.00    0.00   71.21
....

## 查看进程的资源使用情况
$pidstat 1
Linux..... 	11/22/2020 	_x86_64_	(104 CPU)
10:28:16 AM   UID       PID    %usr %system  %guest    %CPU   CPU  Command
10:28:17 AM  1002     56778   25.42   28.81    0.00   54.24    18  java
10:28:17 AM  1002     56789   82.20   64.41    0.00  146.61    60  java
10:28:17 AM  1002     59328   88.98    0.00    0.00   88.98    24  java
10:28:17 AM  1002     72144  110.17   30.51    0.00  140.68    37  java
....
## pidstat和top很像，不同的是它可以每隔一个间隔打印一次，而不是像top那样每次都清屏。这个命令可以方便地哈看进程可能存在的行为模式。
## 这里的 %CPU表明的是对所有CPU的值，比如%110.17 表示这个进程消耗了1.1个CPU

##查看磁盘的当前负载和性能
$iostat -xz 1
Linux 4.9.151-015.ali3000.alios7.x86_64 (bd033027020018.na63) 	11/22/2020 	_x86_64_	(104 CPU)
avg-cpu:  %user   %nice %system %iowait  %steal   %idle
          18.03    0.01    9.86    0.62    0.00   71.48
Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
vda               0.00    15.29    0.09   58.47     2.11  2254.31    77.07     0.30    4.99    2.54    4.99   0.26   1.51
nvme0n1           0.01    77.88   64.98  274.20  2806.25 29936.75   193.07     0.38    0.43    7.81    0.74   0.48  16.30
vdb               0.00     0.89    0.00    1.11     0.00    21.46    38.79     0.00    1.57    0.75    1.57   0.39   0.04
## r/s，w/s，rkB/s,wkB/s：系统发往设备的每秒的读次数，每秒的写次数，每秒读的数据量，每秒写的数据量。这几个指标反映的是系统的工作负载。系统的性能问题很可能就是负载太大
## await： 系统发往IO设备的请求的平均响应时间。这包括请求排队的时间，以及请求处理的时间。超过经验值的平均响应时间表明设备处于饱和状态，或者设备有问题。
## avgqu-sz：设备请求队列的平均长度。队长长度大于1表示设备处于饱和状态
## %util：设备的利用率。设备繁忙的程度，表示每一秒之内，设备处理IO的时间占比。
## 如果这个块设备是一个逻辑块设备，这个逻辑块设备后面有很多物理的磁盘的话，100%利用率智能表明有些IO的处理时间达到了100%；后端的物理磁盘可能远远没有达到饱和状态，可以处理更多的负载。还有一点需要注意的是，较差的磁盘IO性能并不一定意味着应用程序会有问题。应用程序可以有很多方法执行异步IO，而不会阻塞在IO上面；应用程序也可以使用诸如预读取，写缓冲等技术降低IO延迟对自身的影响。

## 查看网络接口的吞吐量
$sar -n DEV 1
Linux  ... 11/22/2020 	_x86_64_	(104 CPU)
10:57:24 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s
10:57:25 AM        lo   3215.00   3215.00   1474.78   1474.78      0.00      0.00      0.00
10:57:25 AM      eth0  57494.00  26847.00  55145.63   6069.74      0.00      0.00      0.00
10:57:25 AM  underlay   2677.00   2323.00    224.34  20899.58      0.00      0.00      0.00
10:57:25 AM      eth1   2687.00   2323.00    271.87  20907.11      0.00      0.00      0.00
$sar -n TCP,ETCP 1
Linux ....	11/22/2020 	_x86_64_	(104 CPU)
11:01:40 AM  active/s passive/s    iseg/s    oseg/s
11:01:41 AM     30.00      8.00  38046.00  39995.00
11:01:40 AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s
11:01:41 AM      7.00      3.00    100.00      0.00     10.00

11:01:41 AM  active/s passive/s    iseg/s    oseg/s
11:01:42 AM     26.00     24.00  36102.00  37718.00
11:01:41 AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s
11:01:42 AM      8.00      0.00      0.00      0.00      8.00
## 可以简单理解 active为出主机的连接（主动连别人，每秒创建的TCP数量），passive为入主机的连接数（别人来连，每秒接受的连接数量）。retrans/s表示每秒钟TCP重传的次数